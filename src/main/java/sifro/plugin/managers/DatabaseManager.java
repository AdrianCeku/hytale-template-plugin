package sifro.plugin.managers;

import com.zaxxer.hikari.HikariDataSource;

import javax.annotation.Nonnull;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * Base class for database managers.
 *
 * <p>Provides a fast and simple, async API intended to be used by other plugins.
 * {@link MySQLDatabaseManager} uses HikariCP to pool connections.
 * {@link SQLiteDatabaseManager} uses dedicated writer and + reader connections.
 * </p>
 *
 * <h2>API:</h2>
 * <ul>
 *   <li>{@link #prepare(String)}: register a SQL string and get an integer id</li>
 *   <li>{@link #update(int, Object...)}: fire-and-forget</li>
 *   <li>{@link #update(int, Consumer, Object...)}: fire-and-forget with error callback</li>
 *   <li>{@link #updateWithRows(int, Object...)}: update that returns affected row count as a {@link CompletableFuture}</li>
 *   <li>{@link #query(int, Object...)}: returns your data as a matrix of {@code [rows][fields]} / {@code Object[][]} with possibly <b>mixed</b> datatypes debending on query</li>
 *   <li>{@link #queryMapped(int, Function, Object...)}: returns your data as a {@code List<T>}, as generated by your mapper function.
 *        The mapper function should take in a row {@code Object[]} and return an object of type {@code T}
 *   </li>
 * </ul>
 *
 * <h2>Threading:</h2>
 * <ul>
 *   <li>Statements are ran by asynchronously by executors</li>
 *   <li>Callbacks use {@code whenCompleteAsync(callback, executor)} to not block the calling thread</li>
 * </ul>
 *
 * <h2>Security: {@link #executeAsync(String)}</h2>
 * {@link #executeAsync(String)} takes in queries as raw strings. <b>Do not pass user input into it</b>.
 * Prefer using {@link #prepare(String)} + {@link #update(int, Object...)} / {@link #query(int, Object...)} where possible
 */
public abstract class DatabaseManager implements AutoCloseable {

    /**
     * Prepared statement registry.
     *
     * <p>Stores raw SQL strings keyed by id. Creates a {@link PreparedStatement} on execution
     *  and binds parameters.</p>
     */
    private final ConcurrentHashMap<Integer, String> statements = new ConcurrentHashMap<>();

    /**
     * Atomic id counter for {@link #prepare(String)}.
     */
    private final AtomicInteger idCounter = new AtomicInteger(0);

    /**
     * Returns a JDBC connection to be used for a specific operation.
     *
     * @param write whether to return a write or read connection
     * @return the connection to be used
     * @throws SQLException if a connection cannot be acquired
     */
    protected abstract Connection getConnection(boolean write) throws SQLException;

    /**
     * Returns an executor to be used for write operations.
     *
     */
    protected abstract ExecutorService writeExecutor();

    /**
     * Returns an executor to be used for read operations.
     *
     */
    protected abstract ExecutorService readExecutor();

    /**
     * Executes raw SQL.
     *
     * <p><b>WARNING:</b> Dangerous if used with untrusted input (SQL injection).
     * Prefer {@link #prepare(String)}.</p>
     *
     * @param sql raw SQL to execute
     * @return future that completes when execution finishes
     */
    public CompletableFuture<Void> executeAsync(String sql) {
        return CompletableFuture.runAsync(() -> {
            try {
                Connection conn = getConnection(true);
                Statement st = conn.createStatement();
                st.execute(sql);
            } catch (SQLException e) {
                throw new CompletionException(e);
            }
        }, writeExecutor());
    }

    /**
     * Registers a SQL statement and returns an integer id.
     *
     * <p>Callers should store the id and reuse it for {@link #update(int, Object...)} and {@link #query(int, Object...)}.</p>
     *
     * @param query SQL string with {@code ?} placeholders
     * @return integer id for later execution
     */
    public int prepare(String query) {
        int id = idCounter.incrementAndGet();
        statements.put(id, query);
        return id;
    }

    /**
     * Retrieves a SQL statement by id.
     *
     * @param id prepared statement id
     * @return SQL string
     * @throws IllegalArgumentException if no statement with the given id exists
     */
    protected String requireStatement(int id) {
        String q = statements.get(id);
        if (q == null) throw new IllegalArgumentException("No statement with id: " + id);
        return q;
    }

    /**
     * Binds the parameters to a {@link PreparedStatement} for execution.
     *
     * @param statement prepared statement
     * @param params parameters to bind
     * @throws SQLException if parameter binding fails
     */
    protected static void bindParameters(PreparedStatement statement, Object... params) throws SQLException {
        if (params == null || params.length == 0) return;
        for (int i = 0; i < params.length; i++) {
            statement.setObject(i + 1, params[i]); //Parameter indices start at 1
        }
    }

    // =====================
    // Writes (UPDATE/INSERT/DELETE)
    // =====================

    /**
     * Executes an UPDATE/INSERT/DELETE asynchronously (fire-and-forget).
     *
     * <p>This method is designed for minimal caller overhead.
     * Any SQL exceptions are ignored intentionally; use the overload with error callback if needed.</p>
     *
     * @param id prepared statement id
     * @param params parameters to bind
     */
    public void update(int id, Object... params) {
        final String sql = requireStatement(id);

        CompletableFuture.runAsync(() -> {
            try {
                Connection conn = getConnection(true);
                PreparedStatement st = conn.prepareStatement(sql);

                bindParameters(st, params);
                st.executeUpdate();
            } catch (SQLException ignored){};
        }, writeExecutor());
    }

    /**
     * Executes an UPDATE/INSERT/DELETE asynchronously (fire-and-forget) and takes in a callback for error handling.
     *
     * @param id prepared statement id
     * @param onError callback invoked on the write executor if an error occurs
     * @param params parameters to bind
     */
    public void update(int id, Consumer<Throwable> onError, Object... params) {
        final String sql = requireStatement(id);

        CompletableFuture.runAsync(() -> {
            try {
                Connection conn = getConnection(true);
                PreparedStatement st = conn.prepareStatement(sql);

                bindParameters(st, params);
                st.executeUpdate();
            } catch (Throwable t) {
                onError.accept(t);
            }
        }, writeExecutor());
    }

    /**
     * Executes an UPDATE/INSERT/DELETE asynchronously and returns affected row count.
     *
     * @param id prepared statement id
     * @param params parameters to bind
     * @return future completing with the affected row count
     */
    public CompletableFuture<Integer> updateWithRows(int id, Object... params) {
        final String sql = requireStatement(id);

        return CompletableFuture.supplyAsync(() -> {
            try {
                Connection conn = getConnection(true);
                PreparedStatement st = conn.prepareStatement(sql);

                bindParameters(st, params);
                return st.executeUpdate();
            } catch (SQLException e) {
                throw new CompletionException(e);
            }
        }, writeExecutor());
    }

    /**
     * Executes an UPDATE/INSERT/DELETE asynchronously and reports result via callback.
     *
     * <p>Callback executs asynchronously via {@code whenCompleteAsync} to not block the calling thread.</p>
     *
     * @param id prepared statement id
     * @param callback callback receiving (rows, error)
     * @param params parameters to bind
     */
    public void updateWithRows(int id, BiConsumer<Integer, Throwable> callback, Object... params) {
        updateWithRows(id, params).whenCompleteAsync(callback, writeExecutor());
    }

    // =====================
    // Reads (SELECT)
    // =====================

    /**
     * Executes a SELECT asynchronously and returns raw results.
     *
     * @param id prepared statement id
     * @param params parameters to bind
     * @return future completing with {@code Object[rows][fields]}
     */
    public CompletableFuture<Object[][]> query(int id, Object... params) {
        final String sql = requireStatement(id);

        return CompletableFuture.supplyAsync(() -> {
            try {
                Connection conn = getConnection(false);
                PreparedStatement st = conn.prepareStatement(sql);

                bindParameters(st, params);
                ResultSet rs = st.executeQuery();

                return resultSetToObjectMatrix(rs);
            } catch (SQLException e) {
                throw new CompletionException(e);
            }
        }, readExecutor());
    }

    /**
     * Executes a SELECT asynchronously and returns raw results via callback.
     *
     * <p>Callback executes asynchronously via {@code whenCompleteAsync} to not block the calling thread.</p>
     *
     * @param id prepared statement id
     * @param callback callback receiving {@code (Object[rows][fields], Throwable err)}
     * @param params parameters to bind
     */
    public void query(int id, BiConsumer<Object[][], Throwable> callback, Object... params) {
        query(id, params).whenCompleteAsync(callback, readExecutor());
    }

    /**
     * Executes a SELECT asynchronously and maps each row to an object.
     *
     * <p>The mapper receives a row as {@code Object[]} (length = column count).</p>
     *
     * @param id prepared statement id
     * @param mapper function that maps a row to an object
     * @param params parameters to bind
     * @return future completing with a list of mapped results
     * @param <T> result element type
     */
    public <T> CompletableFuture<List<T>> queryMapped(int id, Function<Object[], T> mapper, Object... params) {
        final String sql = requireStatement(id);

        return CompletableFuture.supplyAsync(() -> {
            try {
                Connection conn = getConnection(false);
                PreparedStatement stmt = conn.prepareStatement(sql);

                bindParameters(stmt, params);
                ResultSet rs = stmt.executeQuery();

                return resultSetToMappedList(rs, mapper);
            } catch (SQLException e) {
                throw new CompletionException(e);
            }
        }, readExecutor());
    }

    /**
     * Executes a SELECT asynchronously, maps each row to an object and returns results via callback.
     *
     * <p>Callback executes asynchronously via {@code whenCompleteAsync} to not block the calling thread.</p>
     *
     * @param id prepared statement id
     * @param mapper function that maps a row {@code Object[]} to an object {@code T}
     * @param callback callback receiving {@code (List<T>, Throwable err)}
     * @param params parameters to bind
     * @param <T> result element type
     */
    public <T> void queryMapped(int id, Function<Object[], T> mapper, BiConsumer<List<T>, Throwable> callback, Object... params) {
        queryMapped(id, mapper, params).whenCompleteAsync(callback, readExecutor());
    }

    /**
     * Converts a {@link ResultSet} into an {@code Object[][]}.
     *
     * @param rs result set (positioned before first row)
     * @return matrix of row/column values like {@code Object[rows][fields]}
     * @throws SQLException if reading values fails
     */
    protected static Object[][] resultSetToObjectMatrix(ResultSet rs) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int columnCount = meta.getColumnCount();

        ArrayList<Object[]> rows = new ArrayList<>();
        while (rs.next()) {
            Object[] row = new Object[columnCount];
            for (int i = 0; i < columnCount; i++) row[i] = rs.getObject(i + 1);
            rows.add(row);
        }
        return rows.toArray(new Object[0][]);
    }

    /**
     * Converts a {@link ResultSet} into a {@code List<T>} using a mapping function.
     *
     * @param rs result set
     * @param mapper function that maps a row {@code Object[]} to an object {@code T}
     * @return list of objects that are of type {@code T}
     * @throws SQLException if reading values fails
     * @param <T> mapped type
     */
    protected static <T> List<T> resultSetToMappedList(ResultSet rs, Function<Object[], T> mapper) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        int columnCount = meta.getColumnCount();

        ArrayList<T> out = new ArrayList<>();
        while (rs.next()) {
            Object[] row = new Object[columnCount];
            for (int i = 0; i < columnCount; i++) row[i] = rs.getObject(i + 1);
            out.add(mapper.apply(row));
        }
        return out;
    }

    /**
     * Closes the manager and releases all resources.
     *
     * <p>Implementations must stop accepting new tasks, let in-flight tasks finish (best-effort),
     * then close any open JDBC resources.</p>
     */
    @Override
    public abstract void close();
}